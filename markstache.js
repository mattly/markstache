// Generated by CoffeeScript 1.4.0
(function() {
  var curryL, extractFrontMatter, extractSections, frontMatterLine, lexer, markdown, markdownSection, mustache, render, renderHTML, renderText, renderers, startSectionRegex,
    __slice = [].slice;

  markdown = require('marked');

  mustache = require('mustache');

  frontMatterLine = /^(\w+):\s*(.*)$/m;

  extractFrontMatter = function(text) {
    var front, frontMatter, key, line, lines, match, rest, value, _ref, _ref1;
    if (text.match(frontMatterLine)) {
      frontMatter = {};
      _ref = text.split("\n\n"), front = _ref[0], rest = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
      lines = front.split('\n');
      while (match = (_ref1 = lines[0]) != null ? _ref1.match(frontMatterLine) : void 0) {
        line = match[0], key = match[1], value = match[2];
        frontMatter[key.toLowerCase()] = value;
        lines.shift();
      }
      return [frontMatter, rest.join("\n\n")];
    } else {
      return [{}, text];
    }
  };

  markdownSection = function(text, type) {
    var section, _ref;
    _ref = extractFrontMatter(text), section = _ref[0], text = _ref[1];
    section.type = type;
    section.tokens = markdown.lexer(text);
    section.rawText = text;
    return section;
  };

  startSectionRegex = /{%\s*(\w+)\s*%}/;

  extractSections = function(text) {
    var endSection, leading, marker, nextSection, raw, sections, startBody, startPos, type;
    sections = [];
    while (text.length > 0) {
      if (nextSection = text.match(startSectionRegex)) {
        marker = nextSection[0], type = nextSection[1];
        startPos = nextSection.index;
        startBody = startPos + marker.length;
        if (startPos > 0) {
          leading = text.substr(0, startPos);
          sections.push(markdownSection(leading, 'text'));
        }
        endSection = text.match(RegExp("{%\\s*end" + type + "\\s*%}"));
        raw = text.substr(startBody, endSection.index).trim();
        sections.push(markdownSection(raw, type));
        text = text.substring(endSection.index + endSection[0].length).trim();
      } else {
        sections.push(markdownSection(text, 'text'));
        text = '';
      }
    }
    return sections;
  };

  lexer = function(text, callback) {
    var body, info, link, list, name, section, _i, _len, _ref, _ref1;
    try {
      _ref = extractFrontMatter(text), info = _ref[0], body = _ref[1];
      list = extractSections(body);
    } catch (e) {
      return callback(e);
    }
    list.metadata = info;
    list.references = {};
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      section = list[_i];
      _ref1 = section.tokens.links;
      for (name in _ref1) {
        link = _ref1[name];
        list.references[name] = link;
      }
    }
    return callback(null, list);
  };

  render = function(format, tree, context, callback) {
    var chain, next, output, section, sections;
    context.$refs = tree.references;
    sections = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tree.length; _i < _len; _i++) {
        section = tree[_i];
        _results.push(section);
      }
      return _results;
    })();
    output = [];
    next = function() {
      var out;
      if (section = sections.pop()) {
        return renderers[section.type](section, context, format, chain);
      } else {
        out = mustache.render(output.join('\n'), context);
        return callback(null, out);
      }
    };
    chain = function(err, result) {
      if (err) {
        return cb(err);
      }
      output.push(result);
      return next();
    };
    return next();
  };

  curryL = function() {
    var argsL, fn, _i;
    argsL = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), fn = arguments[_i++];
    return function() {
      var argsR;
      argsR = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return fn.apply(void 0, argsL.concat(argsR));
    };
  };

  renderHTML = curryL('html', render);

  renderText = curryL('text', render);

  renderers = {
    text: function(tree, context, format, cb) {
      if (cb === void 0 && format instanceof 'function') {
        cb = format;
        format = 'text';
      }
      switch (format) {
        case 'html':
          tree.tokens.links = context.$refs;
          return cb(null, markdown.parser(tree.tokens));
        default:
          return cb(null, tree.rawText);
      }
    }
  };

  module.exports = {
    extractFrontMatter: extractFrontMatter,
    lexer: lexer,
    renderHTML: renderHTML,
    renderText: renderText,
    renderers: renderers
  };

}).call(this);
